### 类的实例化顺序
按照考虑的顺序如下：<br>
静态的 优先于 非静态的<br>
父类 优先于 子类<br>
变量 优先于 代码块<br>
最后再考虑 构造函数，子类构造函数最后实例化<br>

比如父代码块 比 子变量 先一步实例化<br>
静态子类 比 非静态父类 先实例化<br>

#### 总结如下
父类静态变量、 <br>
父类静态代码块、 <br>
子类静态变量、 <br>
子类静态代码块、 <br>
父类非静态变量（父类实例成员变量）、 <br>
父类构造函数、 <br>
子类非静态变量（子类实例成员变量）、 <br>
子类构造函数。 

### JVM内存参数
#### -Xms 、-Xmx、-XX:newSize、-XX:MaxnewSize、-Xmn <br>
1、-Xms ：表示java虚拟机堆区内存初始内存分配的大小，通常为操作系统可用内存的1/64大小即可，但仍需按照实际情况进行分配。有可能真的按照这样的一个规则分配时，设计出的软件还没有能够运行得起来就挂了。<br>
2、-Xmx： 表示java虚拟机堆区内存可被分配的最大上限，通常为操作系统可用内存的1/4大小。但是开发过程中，通常会将 -Xms 与 -Xmx两个参数的配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。<br>

一般来讲对于堆区的内存分配只需要对上述两个参数进行合理配置即可，但是如果想要进行更加精细的分配还可以对堆区内存进一步的细化，那就要用到下面的三个参数了-XX:newSize、-XX:MaxnewSize、-Xmn。当然这源于对堆区的进一步细化分：新生代、中生代、老生代。java中每新new一个对象所占用的内存空间就是新生代的空间，当java垃圾回收机制对堆区进行资源回收后，那些新生代中没有被回收的资源将被转移到中生代，中生代的被转移到老生代。而接下来要讲述的三个参数是用来控制新生代内存大小的。<br>
 1、** -XX:newSize：表示新生代初始内存的大小 ** ，应该小于 -Xms的值；<br>
 2、-XX:MaxnewSize：表示新生代可被分配的内存的最大上限；当然这个值应该小于 -Xmx的值；<br>
 3、-Xmn：至于这个参数则是对 -XX:newSize、-XX:MaxnewSize两个参数的同时配置，也就是说如果通过-Xmn来配置新生代的内存大小，那么-XX:newSize = -XX:MaxnewSize = -Xmn，虽然会很方便，但需要注意的是这个参数是在JDK1.4版本以后才使用的。
 <br>
 上面所述即为java虚拟机对外提供的可配置堆区的参数，接下来讲述java虚拟机对非堆区内存配置的两个参数：
    <br>
1、-XX:PermSize：表示非堆区初始内存分配大小，其缩写为permanent size（持久化内存）<br>
2、-XX:MaxPermSize：表示对非堆区分配的内存的最大上限。
    <br>
这里面非常要注意的一点是：在配置之前一定要慎重的考虑一下自身软件所需要的非堆区内存大小，因为此处内存是不会被java垃圾回收机制进行处理的地方。并且更加要注意的是 最大堆内存与最大非堆内存的和绝对不能够超出操作系统的可用内存。<br>
